---
title: "Vacancy"
author: "Jonathan J. Borrelli"
date: "Tuesday, September 16, 2014"
output:
  html_document:
    fig_height: 10
    fig_width: 10
runtime: shiny
---

```{r libraries, echo = F}
library(ggplot2)
library(grid)
library(igraph)
library(igraph)
library(NetIndices)
library(data.table)
```

```{r plotting-tools, echo = F}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


plot_net <- function(edges, pos, shell){
  require(ggplot2)
  
  x1 <- c()
  y1 <- c()
  x2 <- c()
  y2 <- c()
  for(i in 1:nrow(edges)){
    x1[i] <- pos$x[edges[i,1]]
    y1[i] <- pos$y[edges[i,1]]
    x2[i] <- pos$x[edges[i,2]]
    y2[i] <- pos$y[edges[i,2]]
  }
  e <- data.frame(x1, y1, x2, y2)
  
  
  p <- ggplot(pos, aes(x = x, y = y)) 
  p <- p + geom_segment(data = e, aes(x = x1, y = y1, xend = x2, yend = y2), alpha = .75)
  p <- p + geom_point(aes(size = factor(shell)), col = "darkgreen") 
  # the rest is just eliminating the background
  p <- p + scale_x_continuous(breaks = NULL) + scale_y_continuous(breaks = NULL) 
  p <- p + theme(panel.background = element_blank()) + theme(legend.position="none")
  p <- p + theme(axis.title.x = element_blank(), axis.title.y = element_blank()) 
  p <- p + theme( legend.background = element_rect(colour = NA)) 
  p <- p + theme(panel.background = element_rect(fill = "white", colour = NA)) 
  p <- p + theme(panel.grid.minor = element_blank(), panel.grid.major = element_blank())
  print(p)
}
```

The model is below. 

```{r model}
makeNET <- function(n, shellpar = c(1.5, 1), thres = 0.2, limit = c(1, 1.5),
                    mode = "lnorm", plot = F, ...){
  
  if(!length(shellpar) == 2){
    stop("shellpar must be a vector of length 2")
  }
  if(!length(limit) == 2){
    stop("limit must be a vector of length 2")
  }
  
  # how big is each crab's shell
  if(mode == "lnorm"){
    shell <- rlnorm(n, shellpar[1], shellpar[2])
  }else if(mode == "unif"){
    shell <- runif(n, shellpar[1], shellpar[2])
  }else if(mode == "exp"){
    shell <- rexp(n)
  }
  
  #where is each crab?
  x <- runif(n)
  y <- runif(n)
  
  #compute distance between each crab
  d <- as.matrix(dist(data.frame(x, y)))
  
  #how far can they see
  thres <- thres
  
  #are they within visual range?
  edge <- matrix(0, ncol = 2)
  for(i in 1:n){
    for(j in 1:n){
      # get all pairs of individuals within the threshold distance
      if(d[i,j] <= thres){adj <- matrix(c(i,j), nrow = 1, ncol = 2)}else{next}
      edge <- rbind(edge, adj)
    }
  }
  # remove first row (0,0)
  edge <- edge[-1,]
  
  #is it a bigger shell
  lower.lim <- limit[1] # how much bigger the shell must be
  upper.lim <- limit[2] # how much bigger the shell can be
  
  rem <- c()
  for(i in 1:nrow(edge)){
    if(shell[edge[i,1]]*lower.lim[1] > shell[edge[i,2]]){
      # remove rows where shell 2 is less than the lower limit
      rem <- c(rem, i)
    }else if(edge[i,1] == edge[i,2]){
      # remove rows where shell 2 is equal to shell 1 (may be redundant)
      rem <- c(rem, i)
    }else if(shell[edge[i,1]]*upper.lim < shell[edge[i,2]] ){
      # remove rows where shell 2 is greater than the upper limit
      rem <- c(rem, i)
    }
  } 
  
  # remove all rows not meeting the conditions above from the edgelist
  edge <- edge[-rem,]
  
  # plot network if plot is set to TRUE
  if(plot){
    plot(graph.edgelist(edge), vertex.size = sqrt(shell), layout = matrix(c(x,y), ncol = 2),
         vertex.label = NA, margin = c(0, 0, 0, 0), edge.arrow.size = .5)
  }
  
  shelldat <- shell[as.numeric(names(table(edge)))]
  # function returns an edgelist and the shell sizes
  
  return(list(edge = edge, shell = shelldat))
  
}
```

```{r shinyplot, echo = F, fig.height = 10, fig.width = 10}
inputPanel(
  sliderInput("n", label = "Number of Individuals", min = 100, max = 300, value = 200, step = 10),
  sliderInput("shell1", label = "Shell Size Par 1", min = 0, max = 5, value = 1.5, step = .5),
  sliderInput("shell2", label = "Shell Size Par 2", min = 1, max = 5, value = 1, step = .5),
  sliderInput("thres", label = "Threshold", min = .05, max = 1, value = .2, step = .05), 
  sliderInput("lowlim", label = "Lower Swap Limit", min = 1, max = 1.5, value = 1, step = .05),
  sliderInput("uplim", label = "Upper Swap Limit", min = 1.1, max = 5, value = 1.1, step = .1),  
  selectInput("distmode", label = "Size Distribution", choices = c("lnorm", "unif", "exp"),
              selected = "lnorm")
)

renderPlot({
  m <- makeNET(n = input$n, shellpar = c(input$shell1, input$shell2), thres = input$thres,
          limit = c(input$lowlim, input$uplim), mode = input$distmode, plot = T) 
}, width = 900, height = 900)

```



